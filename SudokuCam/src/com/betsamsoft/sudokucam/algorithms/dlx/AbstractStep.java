/*
  AbstractStep.java

  Copyright (C) 2008-2009 by Pete Boton, www.jfasttrack.com

  This file is part of Dancing Links Sudoku.

  Dancing Links Sudoku is free for non-commercial use. Contact the author for commercial use.

  You can redistribute and/or modify this software only under the terms of the GNU General Public
  License as published by the Free Software Foundation. Version 2 of the License or (at your option)
  any later version may be used.

  This program is distributed in the hope that it will be useful and enjoyable, but WITH NO
  WARRANTY; not even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the GNU General Public License for more details.

  You should have received a copy of the GNU General Public License along with this program; if not,
  write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307.
*/

package com.betsamsoft.sudokucam.algorithms.dlx;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;


/**
 * A step is a change in the state of a sudoku. Steps are recorded in the puzzle's history so they
 * can be undone and redone later. Steps are also created by hints.
 *
 * @author   Pete Boton
 * @version  2009/05
 */
public abstract class AbstractStep {

    /**
     * A general description, usually the name of a solver. This is provided only by steps
     * generated by hints.
     */
    private final String smallHint;

    /**
     * A detailed description, including the name of a solver and telling where a value can be
     * placed or candidate(s) removed. This is provided only by steps generated by hints.
     */
    private final String bigHint;

    /** The <code>Cell</code>(s) changed by this step. */
    private final Set<Cell> changedCells = new HashSet<Cell>();

    /** The <code>Cell</code>s whose candidates are used to explain this step. */
    private final Set<Cell> explainingCells = new HashSet<Cell>();

    /**
     * Constructs an <code>AbstractStep</code>.
     *
     * @param smallHint  A general description, usually the name of a solver.
     * @param bigHint    A detailed description, telling where a value can be placed or candidate(s)
     *                   removed, and which solving technique is used.
     */
    AbstractStep(final String smallHint, final String bigHint) {
        this.smallHint = smallHint;
        this.bigHint = bigHint;
    }

    /**
     * Gets a general description, usually the name of a solver.
     *
     * @return  A general description, usually the name of a solver.
     */
    public String getSmallHint() {
        return smallHint;
    }

    /**
     * Gets a detailed description, telling where a value can be placed or candidate(s) removed.
     *
     * @return  A detailed description, telling where a value can be placed or candidate(s) removed.
     */
    public String getBigHint() {
        return bigHint;
    }

    /**
     * Adds a <code>Cell</code> to the collection of <code>Cell</code>s changed by this step.
     *
     * @param cell  The <code>Cell</code> to be added.
     */
    public void addChangedCell(final Cell cell) {
        changedCells.add(cell);
    }

    /**
     * Gets an <code>Iterator</code> over the collection of <code>Cell</code>s changed by this step.
     *
     * @return  An <code>Iterator</code> over the <code>Cell</code>s changed by this step.
     */
    public Iterator<Cell> getChangedCells() {
        return changedCells.iterator();
    }

    /**
     * Gets the number of <code>Cell</code>s changed by this step.
     *
     * @return  The number of <code>Cell</code>s changed by this step.
     */
    int getNumberOfChangedCells() {
        return changedCells.size();
    }

    /**
     * Gets whether a given <code>Cell</code> is changed by this step.
     *
     * @param cell  A <code>Cell</code> to be tested.
     * @return      <code>true</code> if the specified <code>Cell</code> is changed by this step.
     *              Otherwise, <code>false</code>.
     */
    public boolean changes(final Cell cell) {
        return changedCells.contains(cell);
    }

    /**
     * Adds a <code>Cell</code> to the collection of <code>Cell</code>s used to explain this step.
     *
     * @param cell  The <code>Cell</code> to be added.
     */
    public void addExplainingCell(final Cell cell) {
        explainingCells.add(cell);
    }

    /**
     * Gets the collection of <code>Cell</code>s used to explain this step.
     *
     * @return  The collection of <code>Cell</code>s used to explain this step.
     */
    public Iterator<Cell> getExplainingCells() {
        return explainingCells.iterator();
    }

    /**
     * Gets whether a given <code>Cell</code> is part of the explanation of this step.
     *
     * @param cell  A <code>Cell</code> to be tested.
     * @return      <code>true</code> if the specified <code>Cell</code> is part of the explanation
     *              of this step.
     */
    public boolean isExplainedBy(final Cell cell) {
        return explainingCells.contains(cell);
    }

    /**
     * Undoes a step. Given that this is the last step taken, restores a sudoku to the state it
     * was in just prior to this step.
     */
    public abstract void undo();

    /** Redoes this step after it was undone. */
    public abstract void redo();
}
